# svc CLI Tool

The `svc` module (`hosts/homeserver/backup/svc/`) is a Python CLI for managing service backups, restores, and lifecycle operations.

## Package Structure
```
svc/
├── svc.py                  # Entry point (~100 lines)
├── config.py               # Pydantic models for services.json
├── exceptions.py           # Custom exceptions + exit codes
├── cli/
│   ├── renderer.py         # Renderer protocol (Rich/Plain/future Textual)
│   ├── parser.py           # argparse setup with completers
│   └── commands/           # Command pattern implementations
│       ├── base.py         # AppContext + Command protocol
│       ├── list_cmd.py     # list, list-backups
│       ├── backup_cmd.py   # backup
│       ├── restore_cmd.py  # restore
│       └── service_cmd.py  # start/stop/restart/logs
├── core/                   # Business logic (no CLI knowledge)
│   ├── path_resolver.py    # Docker volume → filesystem path
│   ├── backup_orchestrator.py
│   ├── restore_orchestrator.py
│   ├── service_manager.py
│   └── service_helpers.py
└── controllers/            # External system interfaces (async)
    ├── systemctl.py        # SystemctlController
    ├── docker.py           # DockerController
    └── restic.py           # ResticRunner
```

## Commands
```bash
svc list                              # List services and backup status
svc list-backups <local|remote> <svc> # List snapshots for a service
svc backup <local|remote> <svc|all>   # Run backup
svc restore <local|remote> <svc> [id] # Restore from snapshot
svc start|stop|restart <svc|all>      # Manage docker-compose services
svc logs <svc> [--no-follow] [--tail] # Stream service logs
```

## Architecture Patterns
- **Async throughout**: All subprocess calls use `asyncio.create_subprocess_exec()` for Textual TUI compatibility
- **Renderer protocol**: Swap `RichRenderer` for `TextualRenderer` without changing business logic
- **Command pattern**: Add new commands by creating a file in `cli/commands/` and registering in `__init__.py`
- **Dependency injection**: `AppContext` provides controllers to commands
- **DRY service actions**: `start/stop/restart` share a single `ServiceActionCommand` base class

## Adding a New Command
1. Create `cli/commands/mycommand_cmd.py`:
```python
from .base import AppContext, Command

class MyCommand(Command):
    @property
    def name(self) -> str:
        return "mycommand"

    async def execute(self, args, ctx: AppContext) -> int:
        # Business logic here
        return 0
```
2. Register in `cli/commands/__init__.py`:
```python
from .mycommand_cmd import MyCommand
ALL_COMMANDS.append(MyCommand())
```
3. Add argparse subparser in `cli/parser.py`

## Configuration
The tool reads `/etc/svc/services.json` (generated by Nix from service metadata). Schema matches the `backup` section of service metadata plus `restore` config.
